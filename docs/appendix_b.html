<HTML>		<HEAD>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<TITLE>			Appendix A		</TITLE>		</HEAD>	<BODY bgcolor="#ffffff"><h2>B. How do I know what capabilities AquaTerm has and how do I use them</h2><p> In the <a href="appendix_a.html" target="_self">previous section</a> "hello.c" used AquaTerm to display its output  which, admittedly, was fairly simple. What about the program  "helloAgain" that relies on the incredibly complex library  "reallyComplexDrawingLib"?</p>  Look in AQTProtocol.h, it's all there. <em>Seriously. It is.</em>  <p>This is how:<BR> When your adapter connects to AquaTerm it receives a proxy for the  object in AquaTerm responsible for communication with the clients. This  object (and the proxy) implements a certain number of methods defined  externally, in the file AQTProtocol.h. Since the adapter has access to  both the protocol and the proxy (via aqtConnection) it can perform all  operations available in AquaTerm.</p>  <p>More info on distributed objects/proxys etc. is available on<BR> <a href="http://developer.apple.com/techpubs/macosx/Cocoa/TasksAndConcepts/ProgrammingTopics/DistrObjects/index.html" target="_blank">developer.apple.com/techpubs/macosx/Cocoa/TasksAndConcepts/ProgrammingTopics/DistrObjects/</a></p>  <p>OK, looking at AQTProtocol makes my brain hurt. What's up with the funny  syntax?<BR> Objective-C is a superset of plain C. The main extension is the syntax  for sending a message to an object:</p><pre>result = [anObject aMessage];</pre><BR>Messages taking paramaters foo and bar look like this:<BR> <pre>newResult = [anObject aMessageWithParametersFoo:foo andBar:bar]; </pre><BR><p> Everything you've always wanted to know about Objective-C but were  afraid to ask is available at <a href="http://developer.apple.com/techpubs/macosx/Cocoa/ObjectiveC/index.html" target="_blank">developer.apple.com/techpubs/macosx/Cocoa/ObjectiveC/</a></p> <p> Another reason for looking at AQTProtocol.h is that no other  documentation exists, at present, and that as new capbilities are added  to AquaTerm, they _will_ appear in AQTProtocol.h.</p>  The calling sequence in the adapter would be something like:<pre> termInfo = [aqtConnection getAquaTermInfo];[aqtConnection selectModel:1];    [aqtConnection setFontWithName:@"Times" size:18.0];    [aqtConnection addString:@"Text!" ... ];    [aqtConnection addPolyline:aBezierPath withIndexedColor:0];    ...    [aqtConnection addPolyline:anotherBezierPath withIndexedColor:3];[aqtConnection renderInViewShouldRelease:YES]; </pre><BR>   <p>Consider the function "frameCanvas(int color)" defined in  "reallyComplexDrawingLib" that draws a border around the canvas (paper,  whatever) of a certain color.</p> An example of how to add the function "frameCanvas(int color)" to our  adapter would look something like this: <ol><li> Add the call to the C functions at the end of adapter.m (you'll have  to add a prototype to C_API.h too, to keep the compiler happy).  void frameCanvas(int color, float lineWidth) {      [adapter frameCanvasWithIndexedColor:color]; }  This just forwards the call to the adapter object.</li> <li> Add the Objective-C method declaration  -(void)frameCanvasWithIndexedColor:(int)color; to the list of methods in @interface AQTAdapter (after the curly braces  but before the @end)</li> <li> Implement the guts of the method to make it do what it should: <pre> -(void)frameCanvasWithIndexedColor:(int)color{  float xSize, ySize;  NSRect aRect;  NSBezierPath *theFrame;  NSDictionary *termInfo = [aqtConnection getAquaTermInfo];  //  // Get some useful info out of the dictionary read from AquaTerm  // by quering the dictionary termInfo for objects corresponding to  // max x- and y-size respectively. The objects are of class NSNumber  // and will have to be queried in turn to return your favourite type.  // All available lookup keys for the dictionary are listed in AQTprotocol.h  //  xSize = [[termInfo objectForKey:@"AQTXMax"] floatValue];  ySize = [[termInfo objectForKey:@"AQTYMax"] floatValue];  //  // Create a frame:  //  aRect = NSMakeRect(0, 0, xSize, ySize);  theFrame = [NSBezierPath bezierPathWithRect:aRect];  //  // Finally, add the newly created frame to the model!  //  [aqtConnection addPolyline:theFrame withIndexedColor:color];}</pre></li> <li> There is no step 4!</li> <p> The funnylooking NSMakeRect(), NSInsetRect() etc. are utility functions,  very useful indeed! More info on all sorts of utility functions here:<BR> <a href="http://developer.apple.com/techpubs/macosx/Cocoa/Reference/Foundation/ObjC_classic/Functions/FoundationFunctions.html" target="_blank">developer.apple.com/techpubs/macosx/Cocoa/Reference/Foundation/ObjC_classic/Functions/FoundationFunctions.html</a></p><br><br><br> </BODY></HTML>  